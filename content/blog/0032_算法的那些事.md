---
title: 算法的那些事
date: 2020-04-07
description: 从宏观角度剖析算法。
tags: ['算法与数据结构']
layout: blog-post
---

## 学习算法和刷题的思路指南

### 数据结构的存储方式
**数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。**
- 队列、栈、散列表：数组、链表皆可实现。
- 图：邻接表就是链表，邻接矩阵就是二维数组。
- 树：用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。

### 数据结构的基本操作
- **对于任何数据结构，其基本操作无非`遍历 + 访问`，即`增删查改`。**
- **数据结构种类很多，但它们存在的目的都是在不同的应用场景，`尽可能高效地增删查改`。**

**如何遍历 + 访问？**我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：
- `线性的`。线性就是for/while迭代为代表。
- `非线性的`。非线性就是递归为代表。

#### 数组遍历框架
```javascript
const traverse = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    // 迭代访问arr[i]
  }
}
```

#### 链表遍历框架(迭代、递归)
```javascript
function ListNode(val) {
  this.val = val
  this.next = null
}
const traverse = (head) => {
  for (let p = head; p !== null; p = p.next) {
    // 迭代访问p.val
  }
}
const traverse = (head) => {
  // 递归访问head.val
  traverse(head.next)
}
```

#### 二叉树的遍历框架(递归)
```javascript
function TreeNode(val) {
  this.val = val
  this.left = this.right = null
}
const traverse = (root) => {
  traverse(root.left)
  traverse(root.right)
}
```

#### N叉树遍历框架
```javascript
function TreeNode(val) {
  this.val = val
  this.children = []
}
const traverse = (root) => {
  for (let child of root.children) {
    traverse(child)
  }
}
```

### 算法刷题指南
- **数据结构是工具，算法是通过合适的工具解决特定问题的方法。**
- **先刷二叉树，先刷二叉树，先刷二叉树！**
- **因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。**
- **只要涉及递归的问题，都是树的问题。**


## 动态规划解题套路框架
**动态规划问题的一般形式就是求最值。**既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举。**
- **存在「重叠子问题」**。
- **具备「最优子结构」**。要符合「最优子结构」，`子问题间必须互相独立`。
- 列出**正确的「状态转移方程」**。`明确「状态」=> 定义dp数组/函数的含义 => 明确「选择」=> 明确base case`。

### 递归算法的时间复杂度怎么计算？
**子问题个数乘以解决一个子问题需要的时间。**子问题个数，即递归树中节点的总数。

- 带备忘录的递归：自顶向下。
- 动态规划：自底向上。动态规划一般都脱离了递归，由循环迭代完成计算。

**千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程**，即这个暴力解。优化方法无非是用备忘录或者DP table，再无奥妙可言。

### 如何列出状态转移方程？
以凑零钱为例子：

1. **先确定「状态」**，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额amount。
2. **然后确定dp函数的定义**：当前的目标金额是n，至少需要dp(n)个硬币凑出该金额。
3. **然后确定「选择」并择优**，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表coins中选择一个硬币，然后目标金额就会减少。
4. **最后明确base case**，显然目标金额为0时，所需硬币数量为0；当目标金额小于0时，无解，返回-1。

解决方案：
- 暴力递归
- 带备忘录的递归：自顶向下
- dp数组的迭代解法：自底向上

`计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举`，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。
- 只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。
- 列出`状态转移方程`，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。
- `备忘录、DP table`就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。
