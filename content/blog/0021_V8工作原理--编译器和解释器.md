---
title: V8工作原理--编译器和解释器
date: 2020-03-16
description: 编译器和解释器：V8是如何执行一段JavaScript代码的？
tags: ['浏览器']
layout: blog-post
---

了解V8执行机制，能帮助你从底层了解JavaScript，也能帮助你深入理解语言转换器Babel、语法检查工具ESLint、前端框架Vue和React的一些底层实现机制。因此，了解V8的编译流程能让你对语言以及相关工具有更加充分的认识。

## 编译器和解释器
按语言的执行流程，可以把语言划分为编译型语言和解释型语言。
- **编译型语言在`程序执行之前`，需要经过编译器的`编译`过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了**。比如C/C++、GO等都是编译型语言。
- **由解释型语言编写的程序，在`每次运行时`都需要通过解释器对程序进行`动态解释和执行`**。比如Python、JavaScript等都属于解释型语言。

**那编译器和解释器是如何“翻译”代码的呢？**
![编译器解释器翻译过程](../assets/浏览器/0047_编译器解释器翻译过程.png)


## V8是如何执行一段JavaScript代码的
V8执行一段代码的流程如下：
![V8执行代码流程](../assets/浏览器/0048_V8执行代码流程.png)
- Ignition：解释器。
- TurboFan：编译器。

### 1 生成抽象语法树(AST)和执行上下文
#### 什么是AST?
```javascript
var myName = '极客时间'
function foo() {
  return 23
}
myName = 'geektime'
foo()
```
![AST](../assets/浏览器/0049_AST.png)

**AST是非常重要的一种`数据结构`**，在很多项目中有着广泛的应用。
- Babel的工作原理就是先将ES6源码转换为AST，然后再将ES6语法的AST转换为ES5语法的AST，最后利用ES5的AST生成JavaScript源代码。`ES6源码 => ES6 AST => ES5 AST => JS源码`。
- ESLint是一个用来检查JavaScript编写规范的插件，其检测流程也是需要将源码转换为AST，然后再**利用AST来检查代码规范化的问题**。

#### AST的生成过程是怎样的？
通常，生成AST需要经过两个阶段。

1. **第一阶段是分词（tokenize），又称为词法分析**，其作用是将一行行的源码拆解成一个个token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。
![词法分析](../assets/浏览器/0050_分词.png)

2. **第二阶段是解析（parse），又称为语法分析**，其作用是将上一步生成的token数据，根据语法规则转为AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

**有了AST 后，那接下来V8就会生成该段代码的执行上下文。**


### 2 生成字节码
有了AST和执行上下文后，那接下来的第二步，解释器Ignition就登场了，它会根据AST生成字节码，并解释执行字节码。

**一开始V8是没有字节码的，而是直接将AST转换为机器码。因为V8需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，引入了字节码。**

**那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？**
- **字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。**
- 机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。
![字节码](../assets/浏览器/0051_字节码.png)


### 3 执行代码
- 如果有一段第一次执行的字节码，`解释器Ignition`会逐条解释执行。
- 在执行字节码的过程中，如果发现有`热点代码（HotSpot）`，比如**一段代码被重复执行多次，这种就称为热点代码**，那么后台的`编译器TurboFan`就会把该段热点的字节码编译为高效的机器码，并把转换后的机器码保存起来，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
- 这种**字节码配合解释器和编译器技术**称为`即时编译（JIT）`。
![即时编译技术](../assets/浏览器/0052_即时编译技术.png)

#### JavaScript的性能优化
- 提升单次脚本的执行速度，`避免JavaScript的长任务霸占主线程`，这样可以使得页面快速响应交互；
- `避免大的内联脚本`，因为在解析HTML的过程中，解析和编译也会占用主线程；
- `减少JavaScript文件的容量`，因为更小的文件会提升下载速度，并且占用更低的内存。
