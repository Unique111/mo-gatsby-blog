---
title: 宏观视角下的浏览器--导航流程与渲染流程
date: 2020-03-12
description: 导航流程：从输入URL到页面展示，这中间发生了什么？渲染流程：HTML、CSS和JavaScript，是如何变成页面的？
tags: ['浏览器']
layout: blog-post
---

疑问：**从输入URL到页面展示，这中间发生了什么？HTML、CSS和JavaScript，是如何变成页面的？**


## 导航流程：从输入URL到页面展示，这中间发生了什么？
从输入URL到页面展示完整流程示意图：
![浏览器导航流程](../assets/浏览器/0014_浏览器导航流程.png)

- 首先，用户从`浏览器进程`里**输入请求信息**；
- 然后，`网络进程`**发起URL请求**；
- 服务器响应URL请求之后，`浏览器进程`就又要开始**准备渲染进程**了；
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为**提交文档**阶段；
- `渲染进程`接收完文档信息之后，便开始**解析页面和加载子资源**，完成页面的渲染。

**用户发出URL请求到页面开始解析的这个过程，就叫做导航。**


### 1 用户输入
当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是**搜索内容**，还是**请求的URL**。
- 搜索内容：地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
- 请求的URL：地址栏会根据规则，把这段内容加上协议，合成为完整的URL。

当按回车后，标签页上的图片便进入`加载状态`。此时页面的内容仍是之前打开页面的内容。


### 2 URL请求过程
`浏览器进程`会通过`进程间通信（IPC）`把URL请求发送至`网络进程`，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。
具体流程如下：
- 首先，网络进程会**查找本地缓存**是否缓存了该资源。若是，直接返回资源给浏览器进程；否则，进入网络请求流程。
- 进行**DNS解析**，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。
- **利用IP地址和服务器建立TCP连接**。连接建立之后，浏览器端会构建请求行、请求头等信息，**向服务器发送请求**。
- 服务器接收到请求信息后，会根据请求信息生成响应数据，并发给`网络进程`。
  - **重定向**：网络进程开始解析响应头，若状态码是301/302，**网络进程会从响应头的Location字段里面读取重定向的地址**，然后再发起新的HTTP或者HTTPS请求。
  - **响应数据类型处理**：**Content-Type是HTTP头中一个非常重要的字段，它告诉浏览器服务器返回的响应体数据是什么类型**，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。
  - 如果Content-Type字段的值被浏览器判断为**下载类型**，那么该请求会被提交给**浏览器的下载管理器**，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。


### 3 准备渲染进程
什么情况下多个页面会同时运行在一个渲染进程中呢？

Chrome的默认策略是，每个标签对应一个渲染进程。但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点(`协议、根域名一致`)的话，那么新页面会复用父页面的渲染进程。**官方把这个默认策略叫 process-per-site-instance。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。


### 4 提交文档
**“文档”是指URL请求的响应体数据。**
- **浏览器进程**将`提交文档的消息`发送给**渲染进程**，渲染进程收到消息后，会**和网络进程建立传输数据的管道**。
- **文档数据传输完成后**，渲染进程会返回`确认提交的消息`给浏览器进程。
- 浏览器进程在收到`确认提交的消息`后，会**更新浏览器界面状态**，包括了`安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面`。


### 5 渲染阶段
一旦文档被提交，渲染进程便开始页面解析和子资源加载。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。


## 渲染流程：HTML、CSS和JavaScript，是如何变成页面的？
由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做**渲染流水线**。包括`构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成`。

对于每个子阶段：
- 开始每个子阶段都有其**输入的内容**；
- 然后每个子阶段有其**处理过程**；
- 最终每个子阶段会生成**输出内容**。

### 提出问题
**如果下载CSS文件阻塞了，会阻塞DOM树的合成吗？会阻塞页面的显示吗？**


### 构建DOM树
为什么要构建DOM树呢？这是**因为浏览器无法直接理解和使用HTML**。
![构建DOM树](../assets/浏览器/0015_DOM树.png)


### 样式计算（Recalculate Style）
样式计算的目的是为了**计算出DOM节点中每个元素的具体样式**，这个阶段大体可分为三步来完成。

1. **把CSS转换为浏览器能够理解的结构。**在控制台中输入`document.styleSheets`即可看到转换的结果。
2. **转换样式表中的属性值，使其标准化。**比如，em => px，blue => rgb(0, 0, 255)，bold => 700。
3. **计算出DOM树中每个节点的具体样式。**这里涉及到**CSS的继承规则和层叠规则**。`CSS继承就是每个DOM节点都包含有父节点的样式`。计算出来得每个DOM节点的样式，会被保存在`ComputedStyle`的结构内。

样式继承的过程如下图：
![样式继承](../assets/浏览器/0016_样式继承.png)


### 布局阶段
接下来就需要**计算出DOM树中`可见元素的几何位置`**，这个计算过程叫做布局。

Chrome在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 1 创建布局树
布局树构造过程如下：
![创建布局树](../assets/浏览器/0017_创建布局树.png)

#### 2 布局计算
有了一棵完整的布局树。那么接下来，就要**计算布局树节点的坐标位置**了。


### 分层
有了布局树后，还不能开始绘制页面。因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，**为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的`图层树（LayerTree）`**。

布局树和图层树关系示意图如下：
![图层树](../assets/浏览器/0018_图层树.png)

- 通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。
- 那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？满足以下任意一点即可：
  - **第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**（position、filter、z-index、opacity，具体规则查看[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)）
  - **第二点，需要剪裁（clip）的地方也会被创建为图层。**


### 图层绘制
渲染引擎实现图层的绘制时，会**把一个图层的绘制拆分成很多小的绘制指令**，然后再把这些指令按照顺序组成一个待`绘制列表`。**所以在图层绘制阶段，输出的内容就是这些待绘制列表。**
![绘制列表](../assets/浏览器/0019_绘制列表.png)


### 栅格化（raster）操作
**绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由`渲染引擎中的合成线程`来完成的。**当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

- 有时候，**图层很大，合成线程会将图层划分为图块（tile）**，这些图块的大小通常是256x256或者512x512。
- 然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的**。`所谓栅格化，是指将图块转换为位图`。
- 图块是栅格化执行的最小单位。渲染进程维护了一个`栅格化的线程池`，所有的图块栅格化都是在线程池内执行的。
- 通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫**快速栅格化**，或者GPU栅格化，**生成的位图被保存在GPU内存中**。
- **渲染进程把`生成图块的指令`发送给GPU**，然后在GPU中执行生成图块的位图，并保存在GPU的内存中。

合成线程提交图块给栅格化线程池：
![合成线程提交图块给栅格化线程池](../assets/浏览器/0020_图块栅格化.png)


### 合成和显示
- 一旦所有图块都被光栅化，`合成线程`就会生成一个`绘制图块的命令——“DrawQuad”`，然后将该命令提交给`浏览器进程`。
- 浏览器进程里面有一个叫`viz的组件`，用来接收合成线程发过来的DrawQuad命令，然后**根据DrawQuad命令，将其页面内容`绘制到内存`中，最后再`将内存显示在屏幕`上**。


### 渲染流程汇总
![整个渲染流程](../assets/浏览器/0021_渲染流水线.png)

- 1 渲染进程将HTML内容转换为能够读懂的**DOM树**结构。
- 2 渲染引擎将CSS样式表转化为浏览器可以理解的**styleSheets**，计算出DOM节点的样式。
- 3 创建**布局树**，并计算元素的布局信息。
- 4 对布局树进行分层，并生成**分层树**。
- 5 为每个图层生成**绘制列表**，并将其提交到合成线程。
- 6 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
- 7 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
- 8 浏览器进程根据DrawQuad消息**生成页面**，并**显示**到显示器上。


## 相关概念

### 更新了元素的几何属性（重排）
重排需要更新完整的渲染流水线，所以开销也是最大的。
![重排](../assets/浏览器/0022_重排.png)

### 更新元素的绘制属性（重绘）
![重绘](../assets/浏览器/0023_重绘.png)

### 直接合成阶段
如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。

所以**相对于重绘和重排，合成能大大提升绘制效率。**
![合成](../assets/浏览器/0024_合成.png)
